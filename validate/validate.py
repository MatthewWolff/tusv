#     file: validate.py
#   author: Jesse Eaton
#  created: 10/23/2017
# modified: 10/23/2017
#  purpose: reports error in copy number for breakpoints, copy number for segments,
#             usage, and phylogeny topology (using robinson foulds distance) after
#             doing maximal matching between copy number profiles of clones


# # # # # # # # # # #
#   I M P O R T S   #
# # # # # # # # # # #

import sys      # for command line arguments
import os       # for manipulating files and folders
import argparse # for command line arguments
import numpy as np
import graphviz

sys.path.insert(0, '../help/')
import file_manager as fm   # sanitizes file and directory arguments


# # # # # # # # # # # # #
#   C O N S T A N T S   #
# # # # # # # # # # # # #

FNAMES = ['C.tsv', 'U.tsv', 'T.dot'] # these files must be in 'actual' and 'expected' dirs. MUST BE IN THIS ORDER


# # # # # # # # # # # # #
#   F U N C T I O N S   #
# # # # # # # # # # # # #

def main(argv):
	args = get_args(argv)
	Ca, Ua, Ta = get_CUT(args['actual_directory'])
	Ce, Ue, Te = get_CUT(args['expected_directory'])
	m, N, l, r = get_mNlr(Ca, Ua)

	# continue here

	print Ca
	print Ce
	print ''

	print Ua
	print Ue
	print ''

	print Ta
	print Te
	print ''

# LAST ROW OF C IS ASSUMED TO BE ROOT NODE
def get_mNlr(C, U):
	N = len(C)
	l = 0
	while C[N-1, l] == 0:
		l += 1
	r = len(C[0, :]) - l
	m = len(U)
	return m, N, l, r

# # # # # # # # # # # # # # # # # # #
#   F I L E S   T O   A R R A Y S   #
# # # # # # # # # # # # # # # # # # #

#  input: dirname (str) name of directory where FNAMES are located
# output: C (np.array of int) [N, l+r] c_k,s is copy number of segment or breakpoint s in clone k
#         U (np.array of float) [m, N] u_p,k is percent of clone k making up sample p
#         T (graphviz.dot.Digraph) directed tree representing phylogeny
def get_CUT(dirname):
	C = np.genfromtxt(dirname + FNAMES[0], dtype = int)
	U = np.genfromtxt(dirname + FNAMES[1], dtype = float)
	T = get_T(open(dirname + FNAMES[2]))
	return C, U, T

def get_T(file):
	T = graphviz.Digraph()
	txt = file.read()
	lines = txt.split('\n')
	lines.pop(0)
	lines.pop(len(lines)-1)
	lines = [ line.replace('\t', '') for line in lines ]
	lines = [ line.replace(' ', '') for line in lines ]
	for line in lines:
		if '->' in line:
			i, j = line.split('->')
			T.edge(i, j)
		else:
			T.node(line)
	return T

# file = open('graph4.dot', 'r')#READING DOT FILE
# text = file.read()
# graphviz.Source(file.read())
# 	exit()
	

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#   C O M M A N D   L I N E   A R G U M E N T   F U N C T I O N S   #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def get_args(argv):
	parser = argparse.ArgumentParser(prog = 'template.py', description = "purpose")
	parser.add_argument('-a', '--actual_directory', required = True, type = lambda x: fm.valid_dir_with_files(parser, x, FNAMES), help = 'directory containing T.dot, C.tsv, and U.tsv that were estimated by tusv.py')
	parser.add_argument('-e', '--expected_directory', required = True, type = lambda x: fm.valid_dir_with_files(parser, x, FNAMES), help = 'directory containing different T.dot, C.tsv, and U.tsv files that were generated by sim.py')
	return vars(parser.parse_args(argv))

def is_valid_file(parser, arg):
	if not os.path.exists(arg):
		parser.error('The file \"' + str(arg) + '\" could not be found.')
	else:
		return open(arg, 'r')


# # # # # # # # # # # # # # # # # # # # # # # # #
#   C A L L   T O   M A I N   F U N C T I O N   #
# # # # # # # # # # # # # # # # # # # # # # # # #

if __name__ == "__main__":
	main(sys.argv[1:])
