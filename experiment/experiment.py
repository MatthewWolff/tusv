#     file: experiment.py
#   author: Jesse Eaton
#  created: 10/24/2017
# modified: 10/24/2017
#  purpose: runs tusv.py on mulitple patients and validates the results


# # # # # # # # # # #
#   I M P O R T S   #
# # # # # # # # # # #

import sys        # for command line arguments
import os         # for manipulating files and folders
import argparse   # for command line arguments
import subprocess # for calling tusv.py and validate.py
import collections
import numpy as np
import multiprocessing as mp

sys.path.insert(0, '../help/')
import file_manager as fm   # sanitizes file and directory arguments
import printer as pt

sys.path.insert(0, '../validate/')
import validate as vd


# # # # # # # # # # # # #
#   C O N S T A N T S   #
# # # # # # # # # # # # #

FNAMES = ['C.tsv', 'U.tsv', 'T.dot'] # these files must be in 'actual' and 'expected' dirs. MUST BE IN THIS ORDER
EXTENSION = '.vcf'
REPORT_FNAME = 'report.txt'
MAX_NUM_LEAVES = 10
MAX_COPY_NUM = 20
MAX_CORD_DESC_ITERS = 1000
MAX_RESTART_ITERS = 1000
NUM_CORES = mp.cpu_count()


# # # # # # # # # # # # #
#   F U N C T I O N S   #
# # # # # # # # # # # # #

def main(argv):
	args = get_args(argv)
	fm.cp_file_structure_to_out_dir(args['input_directory'], args['output_directory'])
	subdir_names = fm.get_subdir_names(args['input_directory'])
	n, c, l, a, t, r, p, m = args['num_leaves'], args['c_max'], args['lambda1'], args['lambda2'], args['cord_desc_iters'], args['restart_iters'], args['processors'], args['time_limit']

	CBs, CSs, Cs, Us, Ts, FUCs, objs = [], [], [], [], [], [], [] # scores for copy number of breakpoints, segments, usages and phylogeny
	for subdir_name in subdir_names:
		in_dir = args['input_directory'] + subdir_name
		out_dir = args['output_directory'] + subdir_name
		pt.printnow('\nrunning ' + subdir_name)
		run_experiment(in_dir, out_dir, n, c, l, a, t, r, p, m)
		score_Cb, score_Cs, score_C, score_U, dist_T, score_FUC, obj_val = vd.get_scores(out_dir, in_dir)
		pt.printnow(' Cb: ' + str(score_Cb))
		pt.printnow(' Cs: ' + str(score_Cs))
		pt.printnow('  C: ' + str(score_C))
		pt.printnow('  U: ' + str(score_U))
		pt.printnow('  T: ' + str(dist_T))
		pt.printnow('FUC: ' + str(score_FUC))
		pt.printnow('obj: ' + str(obj_val))

		CBs.append(score_Cb)
		CSs.append(score_Cs)
		Cs.append(score_C)
		Us.append(score_U)
		Ts.append(dist_T)
		FUCs.append(score_FUC)
		objs.append(obj_val)

	report(args['input_directory'], args['output_directory'], CBs, CSs, Cs, Us, Ts, FUCs, objs)

def report(in_dir, out_dir, CBs, CSs, Cs, Us, Ts, FUCs, obj_vals):
	fname = out_dir + REPORT_FNAME
	fm.touch(fname)

	orig_stdout = sys.stdout
	f = open(fname, 'w')
	sys.stdout = f

	pt.printnow(' input directory: ' + in_dir)
	pt.printnow('output directory: ' + out_dir + '\n')

	results = [
		('|C_tru - C_obs| breakpoints only', CBs),
		('|C_tru - C_obs| segments only', CSs),
		('|C_tru - C_obs|', Cs),
		('|U_tru - U_obs|', Us),
		('|T_tru - T_obs| robinson foulds distane', Ts),
		('|F - UC|', FUCs),
		('|F - UC| + L1*tree_cost + L2*', obj_vals)
	]

	for msg, vals in results:
		pt.printnow(msg)
		pt.printnow('  all: ' + ', '.join([ str(val) for val in sorted(vals) ]))
		pt.printnow('  avg: ' + str(np.average(vals)))
		pt.printnow('  std: ' + str(np.std(vals)))
		pt.printnow('')

	sys.stdout = orig_stdout
	f.close()


def run_experiment(indir, otdir, n, c, l, a, t, r, p, m):
	old_path = os.getcwd()
	os.chdir('..')
	cmd_lst = ['python', 'tusv.py', '-i', indir, '-o', otdir, '-n', str(n), '-c', str(c), '-t', str(t), '-r', str(r), '-p', str(p)]
	if l != None:
		cmd_lst += ['-l', str(l)]
	if a != None:
		cmd_lst += ['-a', str(a)]
	if m != None:
		cmd_lst += ['-m', str(m)]
	cmd = ' '.join(cmd_lst)
	for line in execute(cmd):
		pt.printnow(line, newline = False)
	os.chdir(old_path)

def execute(cmd):
	popen = subprocess.Popen(cmd, stdout = subprocess.PIPE, universal_newlines = True, shell = True)
	for stdout_line in iter(popen.stdout.readline, ""):
		yield stdout_line 
	popen.stdout.close()
	return_code = popen.wait()
	if return_code:
		raise subprocess.CalledProcessError(return_code, cmd)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#   C O M M A N D   L I N E   A R G U M E N T   F U N C T I O N S   #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def get_args(argv):
	parser = argparse.ArgumentParser(prog = 'experiment.py', description = "runs tusv.py on mulitple patients and validates the results")
	parser.add_argument('-i', '--input_directory', required = True, type = lambda x: fm.valid_master_dir_with_files_and_ext(parser, x, FNAMES, EXTENSION), help = 'directory one or multiple subdirectories. each subdirectory should contain T.dot, C.tsv, and U.tsv files that were generated by sim.py')
	parser.add_argument('-o', '--output_directory', required = True, type = lambda x: fm.valid_dir(parser, x), help = 'directory where results from each experiment will go')
	parser.add_argument('-n', '--num_leaves', required = True, type = lambda x: fm.valid_int_in_range(parser, x, 2, MAX_NUM_LEAVES), help = 'number of leaves for inferred binary tree. total number of nodes will be 2*n-1')
	parser.add_argument('-c', '--c_max', required = True, type = lambda x: fm.valid_int_in_range(parser, x, 1, MAX_COPY_NUM), help = 'maximum allowed copy number at any node in the tree')
	parser.add_argument('-l', '--lambda1', type = lambda x: fm.valid_float_above(parser, x, 0.0), help = 'regularization term to weight total tree cost against unmixing error in objective function. setting as 0.0 will put no tree cost constraint. setting as 1.0 will equally consider tree cost and unmixing error.')
	parser.add_argument('-a', '--lambda2', type = lambda x: fm.valid_float_above(parser, x, 0.0), help = 'regularization term to weight error in inferred ratio between copy number of a breakpoint and the copy number of the segment originally containing the position of breakpoint')
	parser.add_argument('-t', '--cord_desc_iters', required = True, type = lambda x: fm.valid_int_in_range(parser, x, 1, MAX_CORD_DESC_ITERS), help = 'maximum number of cordinate descent iterations for each initialization of U')
	parser.add_argument('-r', '--restart_iters', required = True, type = lambda x: fm.valid_int_in_range(parser, x, 1, MAX_RESTART_ITERS), help = 'number of random initializations for picking usage matrix U')
	parser.add_argument('-p', '--processors', required = True, type = lambda x: fm.valid_int_in_range(parser, x, 1, NUM_CORES), help = 'number of processors to use')
	parser.add_argument('-m', '--time_limit', type = int, help = 'maximum time (in seconds) allowed for a single iteration of the cordinate descent algorithm')
	return vars(parser.parse_args(argv))

def is_valid_file(parser, arg):
	if not os.path.exists(arg):
		parser.error('The file \"' + str(arg) + '\" could not be found.')
	else:
		return open(arg, 'r')


# # # # # # # # # # # # # # # # # # # # # # # # #
#   C A L L   T O   M A I N   F U N C T I O N   #
# # # # # # # # # # # # # # # # # # # # # # # # #

if __name__ == "__main__":
	main(sys.argv[1:])
